@mixin padding-x($right, $left: null) {
    padding: {
        right: $right;
        left: if($left != null, $left, $right);
    }
}

@mixin padding-y($top, $bottom: null) {
    padding: {
        top: $top;
        bottom: if($bottom != null, $bottom, $top);
    }
}

@mixin margin-x($right, $left: null) {
    margin: {
        right: $right;
        left: if($left != null, $left, $right);
    }
}

@mixin margin-y($top, $bottom: null) {
    margin: {
        top: $top;
        bottom: if($bottom != null, $bottom, $top);
    }
}

@mixin aspect-ratio($width, $height) {
    position: relative;

    &::before {
        content: "";
        display: block;
        padding-bottom: $height / $width * 100%;
    }
}

@mixin fit-parent-aspect-ratio {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

@mixin absolute-center {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

@mixin absolute-vertical-center {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}

@mixin flex-center($inline: false) {
    display: if($inline, inline-flex, flex);
    justify-content: center;
    align-items: center;
}

@mixin flex-vertical-center($inline: false) {
    display: if($inline, inline-flex, flex);
    align-items: center;
}

@mixin flex-horizontal-center($inline: false) {
    display: if($inline, inline-flex, flex);
    justify-content: center;
}

@mixin can-hover {
    @media (hover: hover) {
        @content;
    }
}

@mixin text-ellipsis {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

// Possible names for this mixin:
// - breakpoint($from: large-1)
// - respond($from: large-1)
// - mq($from: large-1)
// - media($from: large-1)
@mixin respond($from: null, $until: null) {
    $from-breakpoint: map-get($breakpoints, $from);
    $until-breakpoint: map-get($breakpoints, $until);

    // If "$from" isn't "null" then that means a map key has been passed
    // Then if "$from-breakpoint" variable is "null", it means no value with the given key was found, in which case we need to warn the user.
    // Same for "$until"
    @if $from != null and $from-breakpoint == null {
        @warn "No breakpoint named `#{$from}` was found in the '$breakpoints' map.";
    }
    @if $until != null and $until-breakpoint == null {
        @warn "No breakpoint named `#{$until}` was found in the '$breakpoints' map.";
    }

    @if $from-breakpoint != null and $until-breakpoint != null {
        @media (min-width: $from-breakpoint) and (max-width: $until-breakpoint - 1) {
            @content;
        }
    } @else if $from-breakpoint != null {
        @media (min-width: $from-breakpoint) {
            @content;
        }
    } @else {
        @media (max-width: $until-breakpoint - 1) {
            @content;
        }
    }
}

@function str-replace($string, $search, $replace: "") {
    $index: str-index($string, $search);

    @if $index {
        @return str-slice($string, 1, $index - 1) + $replace +
            str-replace(
                str-slice($string, $index + str-length($search)),
                $search,
                $replace
            );
    }

    @return $string;
}

// The source of this function: https://codepen.io/jakob-e/pen/doMoML
@function svg-url($svg) {
    @if not str-index($svg, xmlns) {
        $svg: str-replace(
            $svg,
            "<svg",
            '<svg xmlns="http://www.w3.org/2000/svg"'
        );
    }
    $encoded: "";
    $slice: 2000;
    $index: 0;
    $loops: ceil(str-length($svg) / $slice);
    @for $i from 1 through $loops {
        $chunk: str-slice($svg, $index, $index + $slice - 1);
        $chunk: str-replace($chunk, '"', "'");
        $chunk: str-replace($chunk, "%", "%25");
        $chunk: str-replace($chunk, "#", "%23");
        $chunk: str-replace($chunk, "{", "%7B");
        $chunk: str-replace($chunk, "}", "%7D");
        $chunk: str-replace($chunk, "<", "%3C");
        $chunk: str-replace($chunk, ">", "%3E");

        $encoded: #{$encoded}#{$chunk};
        $index: $index + $slice;
    }
    @return url("data:image/svg+xml,#{$encoded}");
}

@mixin dashed-border($width, $color, $length, $gap, $radius) {
    background-image: svg-url(
        '<svg><rect width="100%" height="100%" stroke="#{$color}" stroke-width="#{$width}" stroke-dasharray="#{$length} #{$gap}" ry="#{$radius}" rx="#{$radius}" fill="none"/></svg>'
    );
}
